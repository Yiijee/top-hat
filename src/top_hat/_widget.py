"""
This module contains four napari widgets declared in
different ways:

- a pure Python function flagged with `autogenerate: true`
    in the plugin manifest. Type annotations are used by
    magicgui to generate widgets for each parameter. Best
    suited for simple processing tasks - usually taking
    in and/or returning a layer.
- a `magic_factory` decorated function. The `magic_factory`
    decorator allows us to customize aspects of the resulting
    GUI, including the widgets associated with each parameter.
    Best used when you have a very simple processing task,
    but want some control over the autogenerated widgets. If you
    find yourself needing to define lots of nested functions to achieve
    your functionality, maybe look at the `Container` widget!
- a `magicgui.widgets.Container` subclass. This provides lots
    of flexibility and customization options while still supporting
    `magicgui` widgets and convenience methods for creating widgets
    from type annotations. If you want to customize your widgets and
    connect callbacks, this is the best widget option for you.
- a `QWidget` subclass. This provides maximal flexibility but requires
    full specification of widget layouts, callbacks, events, etc.

References:
- Widget specification: https://napari.org/stable/plugins/building_a_plugin/guides.html#widgets
- magicgui docs: https://pyapp-kit.github.io/magicgui/

Replace code below according to your needs.
"""

from typing import TYPE_CHECKING

from magicgui import magic_factory
from magicgui.widgets import CheckBox, Container, create_widget
from napari.utils import progress
from napari.utils.notifications import show_error, show_info, show_warning
from qtpy.QtCore import QSettings
from qtpy.QtWidgets import (
    QComboBox,
    QFileDialog,
    QHBoxLayout,
    QInputDialog,
    QLabel,
    QLineEdit,
    QListWidget,
    QListWidgetItem,
    QPushButton,
    QVBoxLayout,
    QWidget,
)
from skimage.util import img_as_float

from .core.cellbody_matching import centroid_matching
from .utils.colors import generate_random_hex_color
from .utils.data_loaders import FAFB_loader
from .utils.plotter import plot_tracts

if TYPE_CHECKING:
    import napari


# Uses the `autogenerate: true` flag in the plugin manifest
# to indicate it should be wrapped as a magicgui to autogenerate
# a widget.
def threshold_autogenerate_widget(
    img: "napari.types.ImageData",
    threshold: "float",
) -> "napari.types.LabelsData":
    return img_as_float(img) > threshold


# the magic_factory decorator lets us customize aspects of our widget
# we specify a widget type for the threshold parameter
# and use auto_call=True so the function is called whenever
# the value of a parameter changes
@magic_factory(
    threshold={"widget_type": "FloatSlider", "max": 1}, auto_call=True
)
def threshold_magic_widget(
    img_layer: "napari.layers.Image", threshold: "float"
) -> "napari.types.LabelsData":
    return img_as_float(img_layer.data) > threshold


# if we want even more control over our widget, we can use
# magicgui `Container`
class ImageThreshold(Container):
    def __init__(self, viewer: "napari.viewer.Viewer"):
        super().__init__()
        self._viewer = viewer
        # use create_widget to generate widgets from type annotations
        self._image_layer_combo = create_widget(
            label="Image", annotation="napari.layers.Image"
        )
        self._threshold_slider = create_widget(
            label="Threshold", annotation=float, widget_type="FloatSlider"
        )
        self._threshold_slider.min = 0
        self._threshold_slider.max = 1
        # use magicgui widgets directly
        self._invert_checkbox = CheckBox(text="Keep pixels below threshold")

        # connect your own callbacks
        self._threshold_slider.changed.connect(self._threshold_im)
        self._invert_checkbox.changed.connect(self._threshold_im)

        # append into/extend the container with your widgets
        self.extend(
            [
                self._image_layer_combo,
                self._threshold_slider,
                self._invert_checkbox,
            ]
        )

    def _threshold_im(self):
        image_layer = self._image_layer_combo.value
        if image_layer is None:
            return

        image = img_as_float(image_layer.data)
        name = image_layer.name + "_thresholded"
        threshold = self._threshold_slider.value
        if self._invert_checkbox.value:
            thresholded = image < threshold
        else:
            thresholded = image > threshold
        if name in self._viewer.layers:
            self._viewer.layers[name].data = thresholded
        else:
            self._viewer.add_labels(thresholded, name=name)


class ExampleQWidget(QWidget):
    # your QWidget.__init__ can optionally request the napari viewer instance
    # use a type annotation of 'napari.viewer.Viewer' for any parameter
    def __init__(self, viewer: "napari.viewer.Viewer"):
        super().__init__()
        self.viewer = viewer

        btn = QPushButton("Click me!")
        btn.clicked.connect(self._on_click)

        self.setLayout(QHBoxLayout())
        self.layout().addWidget(btn)

    def _on_click(self):
        print("napari has", len(self.viewer.layers), "layers")


class TopMatch(QWidget):
    def __init__(self, viewer: "napari.viewer.Viewer"):
        super().__init__()
        self.viewer = viewer
        self.loader = None
        # --- UI Setup ---
        self.setLayout(QVBoxLayout())

        # 1. Data Connection
        connection_layout = QHBoxLayout()
        self.path_edit = QLineEdit()
        self.path_edit.setPlaceholderText("Enter path to FAFB dataset...")
        browse_btn = QPushButton("Browse")
        connect_btn = QPushButton("Connect")
        connection_layout.addWidget(self.path_edit)
        connection_layout.addWidget(browse_btn)
        connection_layout.addWidget(connect_btn)
        self.layout().addLayout(connection_layout)
        # --- Connections ---
        browse_btn.clicked.connect(self._on_browse)
        connect_btn.clicked.connect(self._on_connect)
        # --- Load Settings ---
        self._load_settings()

        # 2. Detect connection
        self.info_label = QLabel(
            "Select points in the viewer to record (z, y, x) coordinates."
        )
        self.layout().addWidget(self.info_label)

        self.points_layer = viewer.add_points(name="Selected Points", ndim=3)
        self.points_layer.events.data.connect(self.on_points_added)

        # Add button to get cluster centroid
        self.centroid_btn = QPushButton("Get Cluster Centroid")
        self.centroid_btn.clicked.connect(self.get_cluster_centroid)
        self.layout().addWidget(self.centroid_btn)

        # Add button for Later functions - ###a pseudo window just for fun. please change this chunk into something useful.
        self.combo_btn = QPushButton("Crazy Thursday V me fifty!!")
        self.combo_btn.clicked.connect(self.Your_Combo)
        self.layout().addWidget(self.combo_btn)

        # Store last calculated centroid
        self.last_centroid = None
        self.last_matched_hemilineages = None

    def _load_settings(self):
        """Load the last used data path from settings."""
        settings = QSettings("top-hat", "hat-viewer")
        last_path = settings.value("data_path", "")
        if last_path:
            self.path_edit.setText(last_path)

    def _save_settings(self):
        """Save the current data path to settings."""
        settings = QSettings("top-hat", "hat-viewer")
        settings.setValue("data_path", self.path_edit.text())

    def _on_connect(self):
        """Connect to the FAFB dataset path."""
        path = self.path_edit.text()
        if not path:
            show_warning("Please provide a path.")
            return

        try:
            # Initialize the loader first (this is fast)
            self.loader = FAFB_loader(path)
            # Then run the validation, which is slow and will show a progress bar
            self.loader.validate_dataset(progress_wrapper=progress)
            show_info("Successfully connected to dataset!")
            self._save_settings()
        except (FileNotFoundError, ValueError, NotADirectoryError) as e:
            show_error(f"Connection failed: {e}")
            self.loader = None

    def _on_browse(self):
        """Open a dialog to select the data directory."""
        path = QFileDialog.getExistingDirectory(
            self, "Select FAFB Dataset Directory"
        )
        if path:
            self.path_edit.setText(path)
            self._on_connect()

    def on_points_added(self, event):
        coords = self.points_layer.data
        labels = [str(i + 1) for i in range(len(coords))]
        self.points_layer.text = {"string": labels, "size": 8, "color": "red"}

    def calculate_centroid(self, indices):
        """Return the centroid coordinates for selected indices."""
        coords = self.points_layer.data
        if len(coords) == 0 or not indices:
            return None
        selected_coords = coords[indices]
        centroid = selected_coords.mean(axis=0)
        return tuple(float(c) for c in centroid)

    def get_cluster_centroid(self):
        coords = self.points_layer.data
        if len(coords) == 0:
            self.info_label.setText("No points selected.")
            return None

        indices_str, ok = QInputDialog.getText(
            self,
            "Input Point Indices",
            "Enter point indices (e.g., 1,2,3 or 1-5) used for calculating the cell cluster centroid:",
        )
        if not ok or not indices_str.strip():
            return None

        try:
            indices = []
            for part in indices_str.split(","):
                part = part.strip()
                if "-" in part:
                    start, end = map(int, part.split("-"))
                    indices.extend(range(start - 1, end))
                elif part:
                    indices.append(int(part) - 1)
            centroid_tuple = self.calculate_centroid(indices)
            if centroid_tuple is None:
                self.info_label.setText("No valid points for centroid.")
                return None
            self.last_centroid = centroid_tuple

            # in napari, create a new Points layer called LM_centroid, and show the centroid
            if "LM_centroid" in self.viewer.layers:
                self.viewer.layers["LM_centroid"].data = [centroid_tuple]
            else:
                self.viewer.add_points(
                    [centroid_tuple],
                    name="LM_centroid",
                    size=15,
                    face_color="yellow",
                )

            # calculate matched hemilineages
            user_centroid = centroid_tuple[::-1]  # change axis order
            print(f"Using user centroid: {user_centroid}")
            result = centroid_matching(user_centroid, self.loader)
            self.last_matched_hemilineages = result  # save the results
            print(f"Matched hemilineages: {result['hemilineages']}")
            return centroid_tuple
        except (OSError, ValueError, KeyError) as e:
            self.info_label.setText(f"Error: {e}")
            return None

    ## delete this chunk for later functions ...start
    def Your_Combo(self):
        """Write matched hemilineages info to Enjoy_the_Combo.txt"""
        if self.last_matched_hemilineages is None:
            self.info_label.setText("No matched hemilineages data to save.")
            return
        try:
            with open("Enjoy_the_Combo.txt", "w") as f:
                f.write(str(self.last_matched_hemilineages))
            self.info_label.setText(
                "Enjoy the Combo!check a file called Enjoy_the_Combo.txt"
            )
        except (OSError, ValueError) as e:
            self.info_label.setText(f"Error saving combo: {e}")

    ## delete this chunk for later functions ...end


class HatViewer(QWidget):
    """
    A napari widget for loading and visualizing FAFB hemilineage data.
    """

    def __init__(self, viewer: "napari.viewer.Viewer"):
        super().__init__()
        self.viewer = viewer
        self.loader = None
        self.added_layers = []

        # --- UI Setup ---
        self.setLayout(QVBoxLayout())

        # 1. Data Connection
        connection_layout = QHBoxLayout()
        self.path_edit = QLineEdit()
        self.path_edit.setPlaceholderText("Enter path to FAFB dataset...")
        browse_btn = QPushButton("Browse")
        connect_btn = QPushButton("Connect")
        connection_layout.addWidget(self.path_edit)
        connection_layout.addWidget(browse_btn)
        connection_layout.addWidget(connect_btn)
        self.layout().addLayout(connection_layout)

        # 2. Data Type Selection
        self.data_type_combo = QComboBox()
        self.data_type_combo.addItems(["Whole neuron", "CBF", "Bundles"])
        self.layout().addWidget(self.data_type_combo)

        # 3. Hemilineage Search and Selection
        self.search_box = QLineEdit()
        self.search_box.setPlaceholderText("Search for hemilineages...")
        self.hemilineage_list_widget = QListWidget()
        self.hemilineage_list_widget.setSelectionMode(
            QListWidget.ExtendedSelection
        )
        self.layout().addWidget(self.search_box)
        self.layout().addWidget(self.hemilineage_list_widget)

        # 4. Action Buttons
        action_layout = QHBoxLayout()
        add_btn = QPushButton("Add Layers")
        clean_btn = QPushButton("Clean All")
        plot_btn = QPushButton("Plot Tracts")
        action_layout.addWidget(add_btn)
        action_layout.addWidget(clean_btn)
        action_layout.addWidget(plot_btn)
        self.layout().addLayout(action_layout)

        # --- Connections ---
        browse_btn.clicked.connect(self._on_browse)
        connect_btn.clicked.connect(self._on_connect)
        add_btn.clicked.connect(self._on_add_layers)
        clean_btn.clicked.connect(self._on_clean_all)
        plot_btn.clicked.connect(self._on_plot_tracts)
        self.search_box.textChanged.connect(self._update_hemilineage_list)

        # --- Load Settings ---
        self._load_settings()

    def _load_settings(self):
        """Load the last used data path from settings."""
        settings = QSettings("top-hat", "hat-viewer")
        last_path = settings.value("data_path", "")
        if last_path:
            self.path_edit.setText(last_path)

    def _save_settings(self):
        """Save the current data path to settings."""
        settings = QSettings("top-hat", "hat-viewer")
        settings.setValue("data_path", self.path_edit.text())

    def _on_connect(self):
        """Connect to the FAFB dataset path."""
        path = self.path_edit.text()
        if not path:
            show_warning("Please provide a path.")
            return

        try:
            # Initialize the loader first (this is fast)
            self.loader = FAFB_loader(path)
            # Then run the validation, which is slow and will show a progress bar
            self.loader.validate_dataset(progress_wrapper=progress)
            show_info("Successfully connected to dataset!")
            self._save_settings()
            self._update_hemilineage_list()
        except (FileNotFoundError, ValueError, NotADirectoryError) as e:
            show_error(f"Connection failed: {e}")
            self.loader = None

    def _on_browse(self):
        """Open a dialog to select the data directory."""
        path = QFileDialog.getExistingDirectory(
            self, "Select FAFB Dataset Directory"
        )
        if path:
            self.path_edit.setText(path)
            self._on_connect()

    def _update_hemilineage_list(self):
        """Update the list of hemilineages based on search text."""
        self.hemilineage_list_widget.clear()
        if not self.loader:
            return

        search_text = self.search_box.text().lower()
        all_hemilineages = self.loader.get_hemilineage_list()

        filtered_list = [
            name for name in all_hemilineages if search_text in name.lower()
        ]

        for name in filtered_list:
            self.hemilineage_list_widget.addItem(QListWidgetItem(name))

    def _on_add_layers(self):
        """Add selected hemilineages as new layers to the viewer."""
        if not self.loader:
            show_warning("Please connect to a dataset first.")
            return

        selected_items = self.hemilineage_list_widget.selectedItems()
        if not selected_items:
            show_warning("No hemilineages selected.")
            return

        data_type = self.data_type_combo.currentText()

        for item in selected_items:
            hemilineage_name = item.text()
            try:
                if data_type == "Whole neuron":
                    data = self.loader.get_whole_neuron_nrrd(hemilineage_name)
                elif data_type == "CBF":
                    data = self.loader.get_cellbody_fiber_nrrd(
                        hemilineage_name
                    )
                else:  # Bundles
                    data = self.loader.get_hat_bundles_nrrd(hemilineage_name)
                layer_name = f"{hemilineage_name}_{data_type}"
                layer_kwargs = {
                    "name": layer_name,
                    "axis_labels": ("x", "y", "z"),
                    "blending": "additive",
                    "contrast_limits": [0, 1],
                    "colormap": generate_random_hex_color(),
                    "scale": (0.38, 0.38, 0.38),
                    "units": ("micron", "micron", "micron"),
                    "metadata": {"hemilineage": hemilineage_name},
                }
                new_layer = self.viewer.add_image(data, **layer_kwargs)
                self.added_layers.append(new_layer)

            except (FileNotFoundError, ValueError) as e:
                show_error(f"Failed to load {hemilineage_name}: {e}")

    def _on_clean_all(self):
        """Remove all layers added by this widget."""
        for layer in self.added_layers:
            if layer in self.viewer.layers:
                self.viewer.layers.remove(layer)
        self.added_layers.clear()
        show_info("Removed all added layers.")

    def _on_plot_tracts(self):
        """Placeholder for plotting tracts."""
        if not self.added_layers:
            show_warning("No layers have been added to plot.")
            return

        # Open a file dialog to get the save path
        save_path, _ = QFileDialog.getSaveFileName(
            self,
            "Save Tracts Plot",
            "",
            "Image Files (*.png);;PDF Files (*.pdf);;All Files (*)",
        )
        if not save_path:
            return

        # Gather info about active layers
        active_hemilineages = {}
        for layer in self.added_layers:
            if layer in self.viewer.layers:
                active_hemilineages[layer.metadata["hemilineage"]] = (
                    layer.colormap.name
                )

        # Call the plotting function
        plot_tracts(active_hemilineages, save_path, self.loader, progress)
        show_info(f"Plotting saved to {save_path}")
